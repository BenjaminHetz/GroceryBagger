Authors: Tyler Egan, Ben Hetz
Project: P2-Constraint Satisfaction

Design:
This program begins by taking in a text file and an optional argument. The 
text file contains the number of bags on the first line, the size of the bag 
on the second, and items with their constraints on each subsequent line. It 
then parses this information and stores it in an ArrayList of objects called 
GroceryItem. These objects hold an item's name, size, constraints, unique id, 
and weight. A BitSet used for comparing items is also stored in the 
GroceryItem, but it is only after all the item's have been created that a 
setConstraintBits() function can be called. It is each items unique id that 
determines which bit it is in the constraintBits. The next thing this program 
does is create another object called GroceryBag. This object stores an 
ArrayList of GroceryItems (those that have been added to the bag), another 
BitSet that says what items can go in it, the number of items in it, the weight 
of all the items in it, and max weight it can hold, and the total number of items 
that need bagged. Once the items and bags have been initialized, the program 
fills the bags based on the optional argument that is, or isn't, passed. If 
the user does not pass any argument, this program will use LCV to get a 
preliminary ordering of the items. MRV is then used for the overall order of the
items with the order from the LCV being used when items have the same MRV value. 
After the items are ordered based on priority of bagging the items, a depth first
search is used to fill the bags. Arc consistency is also used after each item is 
added to ensure that the path currently traveled in the depth first search is not 
a waste of time. If the search succeeds, each bag's content is printed out. If 
it fails, then the word failure is printed out. If the user passes the argument 
-slow, then the same thing occurs, except without arc consistency. The last thing
that can occur is the user passing an argument of -local.


Tested:
The most common thing we did to test was use print statements to show us the 
what had happened and what the state of the program and it's information was 
when it failed when running it against the example input provided in the 
write up. With this, we could see if items were being sorted the way we 
wanted them to, and if they were being added to bags the way we intended 
them to be. After we got the result to print what we wanted, we tested by 
created a few other input tests. One was a real-world example of products 
and size. The next was a semi-complex example with 26 items, with varying 
size and random constraints. The last was an example of an item that was 
too heavy to add. 


Test Results:
On Ben's Laptop:
************************************************************************
Average for GroceryTest1 Over 10 Trials
Stats:
	3 Bags
	7 Max Capacity
	5 Items
Normal: .0896s
Local: .0921s
Slow: .0908s


Average for GroceryTest2 Over 10 Trials
Stats:
	6 Bags
	8 Max Capacity
	10 Items
Normal: .1031s
Local: .1105s
Slow: .1037s


Average for GroceryTest3 Over 10 Trials
Stats:
	10 Bags
	15 Max Capacity
	26 Items
Normal: .1229s
Local: .1344s
Slow: .1229s


Average for GroceryTest4OW Over 10 Trials
NOTE: This file is guaranteed to fail by design so this is time to fail
Stats:
	3 Bags
	7 Max Capacity
	5 Items
Normal: .0921s
Local: .948s
Slow: .0907s
************************************************************************

General Experience: